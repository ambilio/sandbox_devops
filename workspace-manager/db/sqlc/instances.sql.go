// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: instances.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createInstance = `-- name: CreateInstance :one
INSERT INTO instances (
    id, user_id, type, efs_path, ttl_hours
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
`

type CreateInstanceParams struct {
	ID       uuid.UUID `json:"id"`
	UserID   uuid.UUID `json:"user_id"`
	Type     string    `json:"type"`
	EfsPath  string    `json:"efs_path"`
	TtlHours int32     `json:"ttl_hours"`
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, createInstance,
		arg.ID,
		arg.UserID,
		arg.Type,
		arg.EfsPath,
		arg.TtlHours,
	)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.TaskArn,
		&i.ContainerIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
	)
	return i, err
}

const getInstanceByID = `-- name: GetInstanceByID :one
SELECT id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
FROM instances
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetInstanceByID(ctx context.Context, id uuid.UUID) (Instances, error) {
	row := q.db.QueryRowContext(ctx, getInstanceByID, id)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.TaskArn,
		&i.ContainerIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
	)
	return i, err
}

const listExpiredInstances = `-- name: ListExpiredInstances :many
SELECT id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
FROM instances
WHERE
    status = 'running'
    AND task_arn IS NOT NULL
    AND (
        created_at + (ttl_hours || ' hours')::interval < NOW()
        OR last_active < NOW() - INTERVAL '30 minutes'
    )
`

func (q *Queries) ListExpiredInstances(ctx context.Context) ([]Instances, error) {
	rows, err := q.db.QueryContext(ctx, listExpiredInstances)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instances{}
	for rows.Next() {
		var i Instances
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.EfsPath,
			&i.TaskArn,
			&i.ContainerIp,
			&i.TtlHours,
			&i.LastActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserInstances = `-- name: ListUserInstances :many
SELECT id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
FROM instances
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserInstances(ctx context.Context, userID uuid.UUID) ([]Instances, error) {
	rows, err := q.db.QueryContext(ctx, listUserInstances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instances{}
	for rows.Next() {
		var i Instances
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.EfsPath,
			&i.TaskArn,
			&i.ContainerIp,
			&i.TtlHours,
			&i.LastActive,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stopExpiredInstance = `-- name: StopExpiredInstance :exec
UPDATE instances
SET
  status = 'stopped',
  task_arn = NULL,
  container_ip = NULL,
  last_active = NOW()
WHERE id = $1
`

func (q *Queries) StopExpiredInstance(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, stopExpiredInstance, id)
	return err
}

const updateInstanceOnStart = `-- name: UpdateInstanceOnStart :one
UPDATE instances
SET
    task_arn = $2,
    container_ip = $3,
    status = 'running',
    last_active = NOW()
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
`

type UpdateInstanceOnStartParams struct {
	ID          uuid.UUID      `json:"id"`
	TaskArn     sql.NullString `json:"task_arn"`
	ContainerIp sql.NullString `json:"container_ip"`
}

func (q *Queries) UpdateInstanceOnStart(ctx context.Context, arg UpdateInstanceOnStartParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateInstanceOnStart, arg.ID, arg.TaskArn, arg.ContainerIp)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.TaskArn,
		&i.ContainerIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
	)
	return i, err
}

const updateInstanceStatus = `-- name: UpdateInstanceStatus :one
UPDATE instances
SET
    status = $2,
    task_arn = NULL,
    container_ip = NULL,
    last_active = NOW()
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
`

type UpdateInstanceStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateInstanceStatus(ctx context.Context, arg UpdateInstanceStatusParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateInstanceStatus, arg.ID, arg.Status)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.TaskArn,
		&i.ContainerIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
	)
	return i, err
}

const updateLastActive = `-- name: UpdateLastActive :one
UPDATE instances
SET last_active = $2
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, task_arn, container_ip, ttl_hours, last_active, created_at
`

type UpdateLastActiveParams struct {
	ID         uuid.UUID `json:"id"`
	LastActive time.Time `json:"last_active"`
}

func (q *Queries) UpdateLastActive(ctx context.Context, arg UpdateLastActiveParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateLastActive, arg.ID, arg.LastActive)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.TaskArn,
		&i.ContainerIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
	)
	return i, err
}
