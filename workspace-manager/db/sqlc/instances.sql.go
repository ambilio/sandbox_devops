// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: instances.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const clearJupyterData = `-- name: ClearJupyterData :exec
UPDATE instances
SET
    jupyter_task_arn = NULL,
    jupyter_ip = NULL,
    status = 'stopped',
    last_active = NOW()
WHERE id = $1
`

func (q *Queries) ClearJupyterData(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearJupyterData, id)
	return err
}

const clearVSCodeData = `-- name: ClearVSCodeData :exec
UPDATE instances
SET
    vscode_task_arn = NULL,
    vscode_ip = NULL,
    status = 'stopped',
    last_active = NOW()
WHERE id = $1
`

func (q *Queries) ClearVSCodeData(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, clearVSCodeData, id)
	return err
}

const createInstance = `-- name: CreateInstance :one
INSERT INTO instances (
    id, user_id, type, efs_path, ttl_hours
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
`

type CreateInstanceParams struct {
	ID       uuid.UUID `json:"id"`
	UserID   uuid.UUID `json:"user_id"`
	Type     string    `json:"type"`
	EfsPath  string    `json:"efs_path"`
	TtlHours int32     `json:"ttl_hours"`
}

func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, createInstance,
		arg.ID,
		arg.UserID,
		arg.Type,
		arg.EfsPath,
		arg.TtlHours,
	)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.TaskArn,
		&i.ContainerIp,
	)
	return i, err
}

const getInstanceByID = `-- name: GetInstanceByID :one
SELECT id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
FROM instances
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetInstanceByID(ctx context.Context, id uuid.UUID) (Instances, error) {
	row := q.db.QueryRowContext(ctx, getInstanceByID, id)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.TaskArn,
		&i.ContainerIp,
	)
	return i, err
}

const listUserInstances = `-- name: ListUserInstances :many
SELECT id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
FROM instances
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListUserInstances(ctx context.Context, userID uuid.UUID) ([]Instances, error) {
	rows, err := q.db.QueryContext(ctx, listUserInstances, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instances{}
	for rows.Next() {
		var i Instances
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Status,
			&i.EfsPath,
			&i.VscodeTaskArn,
			&i.VscodeIp,
			&i.JupyterTaskArn,
			&i.JupyterIp,
			&i.TtlHours,
			&i.LastActive,
			&i.CreatedAt,
			&i.TaskArn,
			&i.ContainerIp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstanceOnStart = `-- name: UpdateInstanceOnStart :one
UPDATE instances
SET 
    task_arn = $2,
    container_ip = $3,
    status = 'running',
    last_active = NOW()
WHERE id = $1
RETURNING 
    id,
    user_id,
    type,
    efs_path,
    task_arn,
    container_ip,
    status,
    ttl_hours,
    last_active,
    created_at,
    vscode_task_arn,
    vscode_ip,
    jupyter_task_arn,
    jupyter_ip
`

type UpdateInstanceOnStartParams struct {
	ID          uuid.UUID      `json:"id"`
	TaskArn     sql.NullString `json:"task_arn"`
	ContainerIp sql.NullString `json:"container_ip"`
}

type UpdateInstanceOnStartRow struct {
	ID             uuid.UUID      `json:"id"`
	UserID         uuid.UUID      `json:"user_id"`
	Type           string         `json:"type"`
	EfsPath        string         `json:"efs_path"`
	TaskArn        sql.NullString `json:"task_arn"`
	ContainerIp    sql.NullString `json:"container_ip"`
	Status         string         `json:"status"`
	TtlHours       int32          `json:"ttl_hours"`
	LastActive     time.Time      `json:"last_active"`
	CreatedAt      time.Time      `json:"created_at"`
	VscodeTaskArn  sql.NullString `json:"vscode_task_arn"`
	VscodeIp       sql.NullString `json:"vscode_ip"`
	JupyterTaskArn sql.NullString `json:"jupyter_task_arn"`
	JupyterIp      sql.NullString `json:"jupyter_ip"`
}

func (q *Queries) UpdateInstanceOnStart(ctx context.Context, arg UpdateInstanceOnStartParams) (UpdateInstanceOnStartRow, error) {
	row := q.db.QueryRowContext(ctx, updateInstanceOnStart, arg.ID, arg.TaskArn, arg.ContainerIp)
	var i UpdateInstanceOnStartRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.EfsPath,
		&i.TaskArn,
		&i.ContainerIp,
		&i.Status,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
	)
	return i, err
}

const updateInstanceStatus = `-- name: UpdateInstanceStatus :one
UPDATE instances
SET status = $2
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
`

type UpdateInstanceStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateInstanceStatus(ctx context.Context, arg UpdateInstanceStatusParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateInstanceStatus, arg.ID, arg.Status)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.TaskArn,
		&i.ContainerIp,
	)
	return i, err
}

const updateJupyterOnStart = `-- name: UpdateJupyterOnStart :one
UPDATE instances
SET 
    jupyter_task_arn = $2,
    jupyter_ip = $3,
    status = 'running'
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
`

type UpdateJupyterOnStartParams struct {
	ID             uuid.UUID      `json:"id"`
	JupyterTaskArn sql.NullString `json:"jupyter_task_arn"`
	JupyterIp      sql.NullString `json:"jupyter_ip"`
}

func (q *Queries) UpdateJupyterOnStart(ctx context.Context, arg UpdateJupyterOnStartParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateJupyterOnStart, arg.ID, arg.JupyterTaskArn, arg.JupyterIp)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.TaskArn,
		&i.ContainerIp,
	)
	return i, err
}

const updateLastActive = `-- name: UpdateLastActive :one
UPDATE instances
SET last_active = $2
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
`

type UpdateLastActiveParams struct {
	ID         uuid.UUID `json:"id"`
	LastActive time.Time `json:"last_active"`
}

func (q *Queries) UpdateLastActive(ctx context.Context, arg UpdateLastActiveParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateLastActive, arg.ID, arg.LastActive)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.TaskArn,
		&i.ContainerIp,
	)
	return i, err
}

const updateVSCodeOnStart = `-- name: UpdateVSCodeOnStart :one
UPDATE instances
SET 
    vscode_task_arn = $2,
    vscode_ip = $3,
    status = 'running'
WHERE id = $1
RETURNING id, user_id, type, status, efs_path, vscode_task_arn, vscode_ip, jupyter_task_arn, jupyter_ip, ttl_hours, last_active, created_at, task_arn, container_ip
`

type UpdateVSCodeOnStartParams struct {
	ID            uuid.UUID      `json:"id"`
	VscodeTaskArn sql.NullString `json:"vscode_task_arn"`
	VscodeIp      sql.NullString `json:"vscode_ip"`
}

func (q *Queries) UpdateVSCodeOnStart(ctx context.Context, arg UpdateVSCodeOnStartParams) (Instances, error) {
	row := q.db.QueryRowContext(ctx, updateVSCodeOnStart, arg.ID, arg.VscodeTaskArn, arg.VscodeIp)
	var i Instances
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Status,
		&i.EfsPath,
		&i.VscodeTaskArn,
		&i.VscodeIp,
		&i.JupyterTaskArn,
		&i.JupyterIp,
		&i.TtlHours,
		&i.LastActive,
		&i.CreatedAt,
		&i.TaskArn,
		&i.ContainerIp,
	)
	return i, err
}
